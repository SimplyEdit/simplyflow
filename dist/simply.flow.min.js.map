{
  "version": 3,
  "sources": ["../src/state.mjs", "../src/bind.mjs", "../src/model.mjs", "../src/flow.mjs"],
  "sourcesContent": ["const iterate = Symbol('iterate')\nif (!Symbol.xRay) {\n    Symbol.xRay = Symbol('xRay')\n}\nif (!Symbol.Signal) {\n    Symbol.Signal = Symbol('Signal')\n}\n\nconst signalHandler = {\n    get: (target, property, receiver) => {\n        if (property===Symbol.xRay) {\n            return target // don't notifyGet here, this is only called by set\n        }\n        if (property===Symbol.Signal) {\n            return true\n        }\n        const value = target?.[property] // Reflect.get fails on a Set.\n        notifyGet(receiver, property)\n        if (typeof value === 'function') {\n            if (Array.isArray(target)) {\n                return (...args) => {\n                    let l = target.length\n                    // by binding the function to the receiver\n                    // all accesses in the function will be trapped\n                    // by the Proxy, so get/set/delete is all handled\n                    let result = value.apply(receiver, args)\n                    if (l != target.length) {\n                        notifySet(receiver,  makeContext('length', { was: l, now: target.length }) )\n                    }\n                    return result\n                }\n            } else if (target instanceof Set || target instanceof Map) {\n                return (...args) => {\n                    // node doesn't allow you to call set/map functions\n                    // bound to the receiver.. so using target instead\n                    // there are no properties to update anyway, except for size\n                    let s = target.size\n                    let result = value.apply(target, args)\n                    if (s != target.size) {\n                        notifySet(receiver, makeContext( 'size', { was: s, now: target.size }) )\n                    }\n                    // there is no efficient way to see if the function called\n                    // has actually changed the Set/Map, but by assuming the\n                    // 'setter' functions will change the results of the\n                    // 'getter' functions, effects should update correctly\n                    if (['set','add','clear','delete'].includes(property)) {\n                        notifySet(receiver, makeContext( { entries: {}, forEach: {}, has: {}, keys: {}, values: {}, [Symbol.iterator]: {} } ) )\n                    }\n                    return result\n                }\n            } else if (\n                target instanceof HTMLElement\n                || target instanceof Number\n                || target instanceof String\n                || target instanceof Boolean\n            ) {\n                return value.bind(target)\n            } else {\n                // support custom classes, hopefully\n                return value.bind(receiver)\n            }\n        }\n        if (value && typeof value == 'object') {\n            //NOTE: get now returns a signal, set doesn't 'unsignal' the value set\n            return signal(value)\n        }\n        return value\n    },\n    set: (target, property, value, receiver) => {\n        value = value?.[Symbol.xRay] || value // unwraps signal\n        let current = target[property]\n        if (current!==value) {\n            target[property] = value\n            notifySet(receiver, makeContext(property, { was: current, now: value } ) )\n        }\n        if (typeof current === 'undefined') {\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return true\n    },\n    has: (target, property) => { // receiver is not part of the has() call\n        let receiver = signals.get(target) // so retrieve it here\n        if (receiver) {\n            notifyGet(receiver, property)\n        }\n        return Object.hasOwn(target, property)\n    },\n    deleteProperty: (target, property) => {\n        if (typeof target[property] !== 'undefined') {\n            let current = target[property]\n            delete target[property]\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(property,{ delete: true, was: current }))\n        }\n        return true\n    },\n    defineProperty: (target, property, descriptor) => {\n        if (typeof target[property] === 'undefined') {\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return Object.defineProperty(target, property, descriptor)\n    },\n    ownKeys: (target) => {\n        let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n        notifyGet(receiver, iterate)\n        return Reflect.ownKeys(target)\n    }\n\n}\n\n/**\n * Keeps track of the return signal for an update function, as well\n * as signals connected to other objects. \n * Makes sure that a given object or function always uses the same\n * signal\n */\nconst signals = new WeakMap()\n\n/**\n * Creates a new signal proxy of the given object, that intercepts get/has and set/delete\n * to allow reactive functions to be triggered when signal values change.\n */\nexport function signal(v) {\n    if (v[Symbol.Signal]) { // avoid wrapping a Signal inside a Signal\n        let target = v[Symbol.xRay]\n        if (!signals.has(target)) {\n            signals.set(target, v)\n        }\n        v = target\n    } else if (!signals.has(v)) {\n        signals.set(v, new Proxy(v, signalHandler))\n    }\n    return signals.get(v)\n}\n\n/**\n * Lists all effects that are currently listening to changes in\n * the given signal and property\n * returns a list with \n * - effect: the effect function (effect, throttledEffect, clockEffect)\n * - fn: the user provided function to this effect function\n * - signal: the connectedSignal to this user provided function\n * @param Signal signal\n * @param string prop \n * @return array of { effect, fn, signal }\n */\nexport function trace(signal, prop) {\n    const listeners = getListeners(signal, prop)\n    return listeners.map(listener => {\n        return {\n            effect: listener.effectType,\n            fn: listener.effectFunction,\n            signal: signals.get(listener.effectFunction)\n        }\n    })\n}\n\nlet batchedListeners = new Set()\nlet batchMode = 0\n/**\n * Called when a signal changes a property (set/delete)\n * Triggers any reactor function that depends on this signal\n * to re-compute its values\n */\nfunction notifySet(self, context={}) {\n    let listeners = []\n    context.forEach((change, property) => {\n        let propListeners = getListeners(self, property)\n        if (propListeners?.length) {\n            for (let listener of propListeners) {\n                addContext(listener, makeContext(property,change))\n            }\n            listeners = listeners.concat(propListeners)\n        }\n    })\n    listeners = new Set(listeners.filter(Boolean))\n    if (listeners) {\n        if (batchMode) {\n            batchedListeners = batchedListeners.union(listeners)\n        } else {\n            const currentEffect = computeStack[computeStack.length-1]\n            for (let listener of Array.from(listeners)) {\n                if (listener!=currentEffect && listener?.needsUpdate) {\n                    listener()\n                }\n                clearContext(listener)\n            }\n        }\n    }\n}\n\nfunction makeContext(property, change) {\n    let context = new Map()\n    if (typeof property === 'object') {\n        for (let prop in property) {\n            context.set(prop, property[prop])\n        }\n    } else {\n        context.set(property, change)\n    }\n    return context\n}\n\nfunction addContext(listener, context) {\n    if (!listener.context) {\n        listener.context = context\n    } else {\n        context.forEach((change,property)=> {\n            listener.context.set(property, change) // TODO: merge change if needed\n        })\n    }\n    listener.needsUpdate = true\n}\n\nfunction clearContext(listener) {\n    delete listener.context\n    delete listener.needsUpdate\n}\n\n/**\n * Called when a signal property is accessed. If this happens\n * inside a reactor function--computeStack is not empty--\n * then it adds the current reactor (top of this stack) to its\n * listeners. These are later called if this property changes\n */\nfunction notifyGet(self, property) {\n    let currentCompute = computeStack[computeStack.length-1]\n    if (currentCompute) {\n        // get was part of a react() function, so add it\n        setListeners(self, property, currentCompute)\n    }\n}\n\n/**\n * Keeps track of which update() functions are dependent on which\n * signal objects and which properties. Maps signals to update fns\n */\nconst listenersMap = new WeakMap()\n\n/**\n * Keeps track of which signals and properties are linked to which\n * update functions. Maps update functions and properties to signals\n */\nconst computeMap = new WeakMap()\n\n/**\n * Returns the update functions for a given signal and property\n */\nfunction getListeners(self, property) {\n    let listeners = listenersMap.get(self)\n    return listeners ? Array.from(listeners.get(property) || []) : []\n}\n\n/**\n * Adds an update function (compute) to the list of listeners on\n * the given signal (self) and property\n */\nfunction setListeners(self, property, compute) {\n    if (!listenersMap.has(self)) {\n        listenersMap.set(self, new Map())\n    }\n    let listeners = listenersMap.get(self)\n    if (!listeners.has(property)) {\n        listeners.set(property, new Set())\n    }\n    listeners.get(property).add(compute)\n\n    if (!computeMap.has(compute)) {\n        computeMap.set(compute, new Map())\n    }\n    let connectedSignals = computeMap.get(compute)\n    if (!connectedSignals.has(property)) {\n        connectedSignals.set(property, new Set)\n    }\n    connectedSignals.get(property).add(self)\n}\n\n/**\n * Removes alle listeners that trigger the given reactor function (compute)\n * This happens when a reactor is called, so that it can set new listeners\n * based on the current call (code path)\n */\nfunction clearListeners(compute) {\n    let connectedSignals = computeMap.get(compute)\n    if (connectedSignals) {\n        connectedSignals.forEach(property => {\n            property.forEach(s => {\n                let listeners = listenersMap.get(s)\n                if (listeners.has(property)) {\n                    listeners.get(property).delete(compute)\n                }\n            })\n        })\n    }\n}\n\n/**\n * The top most entry is the currently running update function, used\n * to automatically record signals used in an update function.\n */\nlet computeStack = []\n\n/**\n * Used for cycle detection: effectStack contains all running effect\n * functions. If the same function appears twice in this stack, there\n * is a recursive update call, which would cause an infinite loop.\n */\nconst effectStack = []\n\nconst effectMap = new WeakMap()\n/**\n * Used for cycle detection: signalStack contains all used signals. \n * If the same signal appears more than once, there is a cyclical \n * dependency between signals, which would cause an infinite loop.\n */\nconst signalStack = []\n\n/**\n * Runs the given function at once, and then whenever a signal changes that\n * is used by the given function (or at least signals used in the previous run).\n */\nexport function effect(fn) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        computeEffect.effectFunction = fn\n        computeEffect.effectType = effect\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n    }\n    computeEffect.fn = fn\n    effectMap.set(connectedSignal, computeEffect)\n\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n\nexport function destroy(connectedSignal) {\n    // find the computeEffect associated with this signal\n    const computeEffect = effectMap.get(connectedSignal)?.deref()\n    if (!computeEffect) {\n        return\n    }\n\n    // remove all listeners for this effect\n    clearListeners(computeEffect)\n\n    // remove all references to connectedSignal\n    let fn = computeEffect.fn\n    signals.remove(fn)\n\n    effectMap.delete(connectedSignal)\n\n    // if no other references to connectedSignal exist, it will be garbage collected\n}\n\n/**\n * Inside a batch() call, any changes to signals do not trigger effects\n * immediately. Instead, immediately after finishing the batch() call,\n * these effects will be called. Effects that are triggered by multiple\n * signals are called only once.\n * @param Function fn batch() calls this function immediately\n * @result mixed the result of the fn() function call\n */\nexport function batch(fn) {\n    batchMode++\n    let result\n    try {\n        result = fn()\n    } finally {\n        if (result instanceof Promise) {\n            result.then(() => {\n                batchMode--\n                if (!batchMode) {\n                    runBatchedListeners()\n                }\n            })\n        } else {\n            batchMode--\n            if (!batchMode) {\n                runBatchedListeners()\n            }\n        }\n    }\n    return result\n}\n\nfunction runBatchedListeners() {\n    let copyBatchedListeners = Array.from(batchedListeners)\n    batchedListeners = new Set()\n    const currentEffect = computeStack[computeStack.length-1]\n    for (let listener of copyBatchedListeners) {\n        if (listener!=currentEffect && listener?.needsUpdate) {\n            listener()\n        }\n        clearContext(listener)\n    }\n}\n\n/**\n * A throttledEffect is run immediately once. And then only once\n * per throttleTime (in ms).\n * @param Function fn the effect function to run whenever a signal changes\n * @param int throttleTime in ms\n * @returns signal with the result of the effect function fn\n */\nexport function throttledEffect(fn, throttleTime) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let throttled = false\n    let hasChange = true\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        if (throttled && throttled>Date.now()) {\n            hasChange = true\n            return\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeEffect.effectFunction = fn\n        computeEffect.effectType = throttledEffect\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            hasChange = false\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n        throttled = Date.now()+throttleTime\n        globalThis.setTimeout(() => {\n            if (hasChange) {\n                computeEffect()\n            }\n        }, throttleTime)\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n// refactor: Class clock() with an effect() method\n// keep track of effects per clock, and add clock property to the effect function\n// on notifySet add clock.effects to clock.needsUpdate list\n// on clock.tick() (or clock.time++) run only the clock.needsUpdate effects \n// (first create a copy and reset clock.needsUpdate, then run effects)\nexport function clockEffect(fn, clock) {\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let lastTick = -1 // clock.time should start at 0 or larger\n    let hasChanged = true // make sure the first run goes through\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (lastTick < clock.time) {\n            if (hasChanged) {\n                // remove all dependencies (signals) from previous runs \n                clearListeners(computeEffect)\n                computeEffect.effectFunction = fn\n                computeEffect.effectType = clockEffect\n                // record new dependencies on this run\n                computeStack.push(computeEffect)\n                // make sure the clock.time signal is a dependency\n                lastTick = clock.time\n                // call the actual update function\n                let result \n                try {\n                    result = fn(computeEffect, computeStack)\n                } finally {\n                    // stop recording dependencies\n                    computeStack.pop()\n                    if (result instanceof Promise) {\n                        result.then((result) => {\n                            connectedSignal.current = result\n                        })\n                    } else {\n                        connectedSignal.current = result\n                    }\n                    hasChanged = false\n                }\n            } else {\n                lastTick = clock.time\n            }\n        } else {\n            hasChanged = true\n        }\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\nexport function untracked(fn) {\n    const remember = computeStack.slice()\n    computeStack = []\n    try {\n        return fn()\n    } finally {\n        computeStack = remember\n    }\n}", "import { throttledEffect, destroy } from './state.mjs'\n\n/**\n * Implements one way databinding, updating dom elements with matching attributes\n * to changes in signals (see state.mjs)\n * \n * @class\n */\nclass SimplyBind\n{\n    \n    /**\n     * @param Object options - a set of options for this instance, options may include:\n     *  - root (signal) (required) - the root data object that contains al signals that can be bound\n     *  - container (HTMLElement) - the dom element to use as the root for all bindings\n     *  - attribute (string) - the prefix for the field, list and map attributes, e.g. 'data-bind'\n     *  - transformers (object name:function) - a map of transformer names and functions\n     *  - defaultTransformers (object with field, list and map properties)\n     */\n    constructor(options)\n    {\n        /**\n         * A map of HTMLElements and the data bindings on each, in the form of \n         * the connectedSignal returned by the (throttled)Effect.\n         * @type {Map}\n         * @public\n         */\n        this.bindings = new Map()\n\n        const defaultOptions = {\n            container: document.body,\n            attribute: 'data-bind',\n            transformers: {},\n            defaultTransformers: {\n                field: [defaultFieldTransformer],\n                list: [defaultListTransformer],\n                map: [defaultMapTransformer]\n            }\n        }\n        if (!options?.root) {\n            throw new Error('bind needs at least options.root set')\n        }\n        this.options = Object.assign({}, defaultOptions, options)\n        const attribute      = this.options.attribute\n        const bindAttributes = [attribute+'-field',attribute+'-list',attribute+'-map']\n        const bindSelector   = `[${attribute}-field],[${attribute}-list],[${attribute}-map]`\n        const transformAttribute = attribute+'-transform'\n\n        const getBindingAttribute = (el) => {\n            const foundAttribute = bindAttributes.find(attr => el.hasAttribute(attr))\n            if (!foundAttribute) {\n                console.error('No matching attribute found',el,attr)\n            }\n            return foundAttribute\n        }\n\n        // sets up the effect that updates the element if its\n        // data binding value changes\n        const render = (el) => {\n            this.bindings.set(el, throttledEffect(() => {\n                if (!el.isConnected) {\n                    // el is no longer part of this document\n                    untrack(el, this.getBindingPath(el))\n                    destroy(this.bindings.get(el))\n                    // doing this here instead of in a mutationobserver\n                    // allows an element to be temporary removed and then inserted\n                    // without the binding having to be reset\n                    return\n                }\n                const context = {\n                    templates: el.querySelectorAll(':scope > template'),\n                    attribute: getBindingAttribute(el)\n                }\n                context.path = this.getBindingPath(el)\n                context.value = getValueByPath(this.options.root, context.path)\n                context.element = el\n                track(el, context)\n                runTransformers(context)\n            }, 50))\n        }\n\n        // finds and runs applicable transformers\n        // creates a stack of transformers, calls the topmost\n        // each transformer can opt to call the next or not\n        // transformers should return the context object (possibly altered)\n        const runTransformers = (context) => {\n            let transformers\n            switch(context.attribute) {\n                case this.options.attribute+'-field':\n                    transformers = this.options.defaultTransformers.field || []\n                    break\n                case this.options.attribute+'-list':\n                    transformers = this.options.defaultTransformers.list || []\n                    break\n                case this.options.attribute+'-map':\n                    transformers = this.options.defaultTransformers.map || []\n                    break\n            }\n            if (context.element.hasAttribute(transformAttribute)) {\n                context.element.getAttribute(transformAttribute)\n                    .split(' ').filter(Boolean)\n                    .forEach(t => {\n                        if (this.options.transformers[t]) {\n                            transformers.push(this.options.transformers[t])\n                        } else {\n                            console.warn('No transformer with name '+t+' configured', {cause:context.element})\n                        }\n                    })\n            }\n            let next\n            for (let transformer of transformers) {\n                next = ((next, transformer) => {\n                    return (context) => {\n                        return transformer.call(this, context, next)\n                    }\n                })(next, transformer)\n            }\n            next(context)\n        }\n\n        // given a set of elements with data bind attribute\n        // this renders each of those elements\n        const applyBindings = (bindings) => {\n            for (let bindingEl of bindings) {\n                if (!this.bindings.get(bindingEl)) { // bindingEl may have moved from somewhere else in this document\n                    render(bindingEl)\n                }\n            }\n        }\n\n        // this handles the mutation observer changes\n        // if any element is added, and has a data bind attribute\n        // it applies that data binding\n        const updateBindings = (changes) => {\n            const selector = `[${attribute}-field],[${attribute}-list],[${attribute}-map]`\n            for (const change of changes) {\n                if (change.type==\"childList\" && change.addedNodes) {\n                    for (let node of change.addedNodes) {\n                        if (node instanceof HTMLElement) {\n                            let bindings = Array.from(node.querySelectorAll(selector))\n                            if (node.matches(selector)) {\n                                bindings.unshift(node)\n                            }\n                            if (bindings.length) {\n                                applyBindings(bindings)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // this responds to elements getting added to the dom\n        // and if any have data bind attributes, it applies those bindings\n        this.observer = new MutationObserver((changes) => {\n            updateBindings(changes)\n        })\n\n        this.observer.observe(this.options.container, {\n            subtree: true,\n            childList: true\n        })\n\n        // this finds elements with data binding attributes and applies those bindings\n        // must come after setting up the observer, or included templates\n        // won't trigger their own bindings\n        const bindings = this.options.container.querySelectorAll(\n            ':is(['+this.options.attribute+'-field]'+\n            ',['+this.options.attribute+'-list]'+\n            ',['+this.options.attribute+'-map]):not(template)'\n        )\n        if (bindings.length) {\n            applyBindings(bindings)\n        }\n\n    }\n\n    /**\n     * Finds the first matching template and creates a new DocumentFragment\n     * with the correct data bind attributes in it (prepends the current path)\n     * @param Context context\n     * @return DocumentFragment\n     */\n    applyTemplate(context)\n    {\n        const path      = context.path\n        const templates = context.templates\n        const list      = context.list\n        const index     = context.index\n        const parent    = context.parent\n        const value     = list ? list[index] : context.value\n\n        let template = this.findTemplate(templates, value)\n        if (!template) {\n            let result = new DocumentFragment()\n            result.innerHTML = '<!-- no matching template -->'\n            return result\n        }\n        let clone = template.content.cloneNode(true)\n        if (!clone.children?.length) {\n            return clone\n        }\n        if (clone.children.length>1) {\n            throw new Error('template must contain a single root node', { cause: template })\n        }\n        const attribute = this.options.attribute\n        const attributes = [attribute+'-field',attribute+'-list',attribute+'-map']\n        const bindings = clone.querySelectorAll(`[${attribute}-field],[${attribute}-list],[${attribute}-map]`)\n        for (let binding of bindings) {\n            const attr = attributes.find(attr => binding.hasAttribute(attr))\n            const bind = binding.getAttribute(attr)\n            if (bind.substring(0, ':root.'.length)==':root.') {\n                binding.setAttribute(attr, bind.substring(':root.'.length))\n            } else if (bind==':value' && index!=null) {\n                binding.setAttribute(attr, path+'.'+index)\n            } else if (index!=null) {\n                binding.setAttribute(attr, path+'.'+index+'.'+bind)\n            } else {\n                binding.setAttribute(attr, parent+'.'+bind)\n            }\n        }\n        if (typeof index !== 'undefined') {\n            clone.children[0].setAttribute(attribute+'-key',index)\n        }\n        // keep track of the used template, so if that changes, the item can be updated\n        Object.defineProperty(\n            clone.children[0],\n            '$bindTemplate',\n            {\n                value: template,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        )\n        // return clone, not the firstChild, so that all whitespace is cloned as well\n        return clone\n    }\n\n    /**\n     * Returns the path referenced in either the field, list or map attribute\n     * @param HTMLElement el\n     * @return string The path referenced, or void\n     */\n    getBindingPath(el)\n    {\n        const attributes = [\n            this.options.attribute+'-field', \n            this.options.attribute+'-list',\n            this.options.attribute+'-map'\n        ]\n        for (let attr of attributes) {\n            if (el.hasAttribute(attr)) {\n                return el.getAttribute(attr)\n            }\n        }\n    }\n\n    /**\n     * Finds the first template from an array of templates that\n     * matches the given value. \n     */\n    findTemplate(templates, value)\n    {\n        const templateMatches = t => {\n            // find the value to match against (e.g. data-bind=\"foo\")\n            let path = this.getBindingPath(t)\n            let currentItem\n            if (path) {\n                if (path.substr(0,6)==':root.') {\n                    currentItem = getValueByPath(this.options.root, path)\n                } else {\n                    currentItem = getValueByPath(value, path)\n                }\n            } else {\n                currentItem = value\n            }\n\n            // then check the value against pattern, if set (e.g. data-bind-match=\"bar\")\n            const strItem = ''+currentItem\n            let matches = t.getAttribute(this.options.attribute+'-match')\n            if (matches) {\n                if (matches===':empty' && !currentItem) {\n                    return t\n                } else if (matches===':notempty' && currentItem) {\n                    return t\n                }\n                if (strItem.match(matches)) {\n                    return t\n                }\n            }\n            if (!matches && currentItem!==null && currentItem!==undefined) {\n                //FIXME: this doesn't run templates in lists where list entry is null\n                //which messes up the count\n                //\n                // no data-bind-match is set, so return this template\n                return t\n            }\n        }\n        let template = Array.from(templates).find(templateMatches)\n        let rel = template?.getAttribute('rel')\n        if (rel) {\n            let replacement = document.querySelector('template#'+rel)\n            if (!replacement) {\n                throw new Error('Could not find template with id '+rel)\n            }\n            template = replacement\n        }\n        return template\n    }\n\n    destroy()\n    {\n        this.bindings.forEach(binding => {\n            destroy(binding)\n        })\n        this.bindings = new Map()\n        this.observer.disconnect()\n    }\n\n}\n\n/**\n * Returns a new instance of SimplyBind. This is the normal start\n * of a data bind flow\n */\nexport function bind(options)\n{\n    return new SimplyBind(options)\n}\n\nconst tracking = new Map()\n\nexport function trace(path)\n{\n    return tracking.get(path)\n}\n\nfunction track(el, context) {\n    if (!tracking.has(context.path)) {\n        tracking.set(context.path, [context])\n    } else {\n        tracking.get(context.path).push(context)\n    }\n}\n\nfunction untrack(el, path) {\n    let list = tracking.get(path)\n    list = list.filter(context => context.element == el)\n    tracking.set(path, list)\n}\n\n/**\n * Returns true if a matches b, either by having the\n * same string value, or matching string :empty against a falsy value\n */\nexport function matchValue(a,b)\n{\n    if (a==':empty' && !b) {\n        return true\n    }\n    if (b==':empty' && !a) {\n        return true\n    }\n    if (''+a == ''+b) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns the value by walking the given path as a json pointer, starting at root\n * if you have a property with a '.' in its name urlencode the '.', e.g: %46\n * \n * @param HTMLElement root\n * @param string path e.g. 'foo.bar'\n * @return mixed the value found by walking the path from the root object or undefined\n */\nexport function getValueByPath(root, path)\n{\n    let parts = path.split('.');\n    let curr = root;\n    let part, prevPart;\n    while (parts.length && curr) {\n        part = parts.shift()\n        if (part==':key') {\n            return prevPart\n        } else if (part==':value') {\n            return curr\n        } else if (part==':root') {\n            curr = root\n        } else {\n            part = decodeURIComponent(part)\n            curr = curr[part];\n            prevPart = part\n        }\n    }\n    return curr\n}\n\n/**\n * Default transformer for data binding\n * Will be used unless overriden in the SimplyBind options parameter\n */\nexport function defaultFieldTransformer(context)\n{\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (templates?.length) {\n        transformLiteralByTemplates.call(this, context)\n    } else {\n        switch(el.tagName) {\n            case 'INPUT':\n                transformInput.call(this, context)\n                break\n            case 'BUTTON':\n                transformButton.call(this, context)\n                break\n            case 'SELECT':\n                transformSelect.call(this, context)\n                break\n            case 'A':\n                transformAnchor.call(this, context)\n                break\n            case 'IMG':\n                transformImage.call(this, contet)\n                break\n            case 'IFRAME':\n                transformIframe.call(this, context)\n                break\n            case 'META':\n                transformMeta.call(this, context)\n                break\n            case 'TEMPLATE': // never touch templates!\n                break\n            default:\n                transformElement.call(this, context)\n                break\n        }\n    }\n    return context\n}\n\nexport function defaultListTransformer(context)\n{\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (!Array.isArray(value)) {\n        console.error('Value is not an array.', el, path, value)\n    } else if (!templates?.length) {\n        console.error('No templates found in', el)\n    } else {\n        transformArrayByTemplates.call(this, context)\n    }\n    return context\n}\n\nexport function defaultMapTransformer(context)\n{\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (typeof value != 'object') {\n        console.error('Value is not an object.', el, path, value)\n    } else if (!templates?.length) {\n        console.error('No templates found in', el)\n    } else {\n        transformObjectByTemplates.call(this, context)\n    }\n    return context\n}\n\n\n/**\n * Renders an array value by applying templates for each entry\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n * FIXME: this doesn't handle situations where there is no matching template\n * this messes up self healing. check transformObjectByTemplates for a better implementation\n */\nexport function transformArrayByTemplates(context)\n{\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    let items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    // do single merge strategy for now, in future calculate optimal merge strategy from a number\n    // now just do a delete if a key <= last key, insert if a key >= last key\n    let lastKey = 0\n    let skipped = 0\n    context.list  = value\n    for (let item of items) {\n        let currentKey = parseInt(item.getAttribute(attribute+'-key'))\n        if (currentKey>lastKey) {\n            // insert before\n            context.index = lastKey\n            el.insertBefore(this.applyTemplate(context), item)\n        } else if (currentKey<lastKey) {\n            // remove this\n            item.remove()\n        } else {\n            // check that all data-bind params start with current json path or ':root', otherwise replaceChild\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            if (item.matches(`[${attribute}]`)) {\n                bindings.unshift(item)\n            }\n            let needsReplacement = bindings.find(b => {\n                let databind = b.getAttribute(attribute)\n                return (databind.substr(0,5)!==':root' \n                    && databind.substr(0, path.length)!==path)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[lastKey])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n            if (needsReplacement) {\n                context.index = lastKey\n                el.replaceChild(this.applyTemplate(context), item)\n            }\n        }\n        lastKey++\n        if (lastKey>=value.length) {\n            break\n        }\n    }\n    items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length > value.length) {\n        while (length > value.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < value.length ) {\n        while (length < value.length) {\n            context.index = length\n            el.appendChild(this.applyTemplate(context))\n            length++\n        }\n    }\n}\n\n/**\n * Renders an object value by applying templates for each entry (Object.entries)\n * Replaces,moves or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformObjectByTemplates(context)\n{\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n    context.list = value\n\n    let items = Array.from(el.querySelectorAll(':scope > ['+attribute+'-key]'))\n    for (let key in context.list) {\n        context.index = key\n        let item = items.shift()\n        if (!item) { // more properties than rendered items\n            let clone = this.applyTemplate(context)\n            el.appendChild(clone)\n            continue\n        }\n        if (item.getAttribute[attribute+'-key']!=key) { \n            // next item doesn't match key\n            items.unshift(item) // put item back for next cycle\n            let outOfOrderItem = el.querySelector(':scope > ['+attribute+'-key=\"'+key+'\"]') //FIXME: escape key\n            if (!outOfOrderItem) {\n                let clone = this.applyTemplate(context)\n                el.insertBefore(clone, item)\n                continue // new template doesn't need replacement, so continue \n            } else {\n                el.insertBefore(outOfOrderItem, item)\n                item = outOfOrderItem // check needsreplacement next\n                items = items.filter(i => i!=outOfOrderItem)\n            }\n        }\n        let newTemplate = this.findTemplate(templates, value[key])\n        if (newTemplate != item.$bindTemplate){\n            let clone = this.applyTemplate(context)\n            el.replaceChild(clone, item)\n        }\n    }\n    // clean up remaining items\n    while (items.length) {\n        let item = items.shift()\n        item.remove()\n    }\n}\n\nfunction getParentPath(el, attribute)\n{\n    const parentEl  = el.parentElement?.closest(`[${attribute}-list],[${attribute}-map]`)\n    if (!parentEl) {\n        return ':root'\n    }\n    if (parentEl.hasAttribute(`${attribute}-list`)) {\n        return parentEl.getAttribute(`${attribute}-list`)\n    }\n    return parentEl.getAttribute(`${attribute}-map`)\n}\n\n/**\n * transforms the contents of an html element by rendering\n * a matching template, once.\n * data-bind attributes inside the template use the same\n * parent path as this html element uses\n */\nexport function transformLiteralByTemplates(context)\n{\n    const el             = context.element\n    const templates      = context.templates\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    const rendered = el.querySelector(':scope > :not(template)')\n    const template = this.findTemplate(templates, value)\n\n    context.parent = getParentPath(el, attribute)\n    if (rendered) {\n        if (template) {\n            if (rendered?.$bindTemplate != template) {\n                const clone = this.applyTemplate(context)\n                el.replaceChild(clone, rendered)\n            }\n        } else {\n            el.removeChild(rendered)\n        }\n    } else if (template) {\n        const clone = this.applyTemplate(context)\n        el.appendChild(clone)\n    }\n}\n\n/**\n * transforms a single input type\n * for radio/checkbox inputs it only sets the checked attribute to true/false\n * if the value attribute matches the current value\n * for other inputs the value attribute is updated\n */\nexport function transformInput(context)\n{\n    const el  = context.element\n    let value = context.value\n\n    transformElement(context)\n    if (typeof value == 'undefined') {\n        value = ''\n    }\n    if (el.type=='checkbox' || el.type=='radio') {\n        if (matchValue(el.value, value)) {\n            el.checked = true\n        } else {\n            el.checked = false\n        }\n    } else if (!matchValue(el.value, value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the value of the button, doesn't touch the innerHTML\n */\nexport function transformButton(context)\n{\n    const el    = context.element\n    const value = context.value\n\n    transformElement(context)\n    setProperties(el, value, 'value')\n}\n\n/**\n * Sets the selected attribute of select options\n */\nexport function transformSelect(context)\n{\n    const el  = context.element\n    let value = context.value\n\n    if (value === null) {\n        value = ''\n    }\n    if (typeof value!='object') {\n        if (el.multiple) {\n            if (Array.isArray(value)) { //FIXME: cannot be true, since typeof != 'object'\n                for (let option of el.options) {\n                    if (value.indexOf(option.value)===false) {\n                        option.selected = false\n                    } else {\n                        option.selected = true\n                    }\n                }\n            }\n        } else {\n            let option = el.options.find(o => matchValue(o.value,value))\n            if (option) {\n                option.selected = true\n                option.setAttribute('selected', true)\n            }\n        }\n    } else { // value is a non-null object\n        if (value.options) {\n            setSelectOptions(el, value.options)\n        }\n        if (value.selected) {\n            transformSelect(Object.asssign({}, context, {value:value.selected}))\n        }\n        setProperties(el, value, 'name', 'id', 'selectedIndex', 'className') // allow innerHTML? if so call transformElement instead\n    }\n}\n\nexport function addOption(select, option)\n{\n    if (!option) {\n        return\n    }\n    if (typeof option !== 'object') {\n        select.options.add(new Option(''+option))\n    } else if (option.text) {\n        select.options.add(new Option(option.text, option.value, option.defaultSelected, option.selected))\n    } else if (typeof option.value != 'undefined') {\n        select.options.add(new Option(''+option.value, option.value, option.defaultSelected, option.selected))\n    }\n}\n\nexport function setSelectOptions(select,options)\n{\n    //@TODO: only update in case of changes?\n    select.innerHTML = ''\n    if (Array.isArray(options)) {\n        for (const option of options) {\n            addOption(select, option)\n        }\n    } else if (options && typeof options == 'object') {\n        for (const option in options) {\n            addOption(select, { text: options[option], value: option })\n        }\n    }\n}\n\n/**\n * Sets the innerHTML and href attribute of an anchor\n * TODO: support target, title, etc. attributes\n */\nexport function transformAnchor(context)\n{\n    const el    = context.element\n    const value = context.value\n\n    transformElement(context)\n    setProperties(el, value, 'title', 'target', 'href', 'name', 'newwindow', 'nofollow')\n}\n\nexport function transformImage(context)\n{\n    const el    = context.element\n    const value = context.value\n\n    transformElement(context)\n    setProperties(el, value, 'title', 'alt', 'src')\n}\n\nexport function transformIframe(context)\n{\n    const el    = context.element\n    const value = context.value\n\n    transformElement(context)\n    setProperties(el, value, 'title', 'src')\n}\n\nexport function transformMeta(context)\n{\n    const el    = context.element\n    const value = context.value\n\n    transformElement(context)\n    setProperties(el, value, 'content')    \n}\n/**\n * sets the innerHTML and title and id properties of any HTML element\n */\nexport function transformElement(context)\n{\n    const el  = context.element\n    let value = context.value\n\n    if (typeof value=='undefined' || value==null) {\n        value = ''\n    }\n    let strValue = ''+value\n    if (typeof value!='object' || strValue.substring(0,8)!='[object ') {\n        el.innerHTML = strValue\n        return\n    }\n    setProperties(el, value, 'innerHTML', 'title', 'id', 'className')\n}\n\n/**\n * Sets a list of properties on a dom element, equal to \n * the string value of a data object\n * only updates the dom element if the property doesn't match\n */\nexport function setProperties(el, data, ...properties) {\n    if (!data || typeof data!=='object') {\n        return\n    }\n    for (const property of properties) {\n        if (typeof data[property] === 'undefined') {\n            continue\n        }\n        if (matchValue(el[property], data[property])) {\n            continue\n        }\n        if (data[property] === null) {\n            el[property] = ''\n        } else {\n            el[property] = ''+data[property]\n        }\n    }\n}\n", "import {signal, effect, throttledEffect, batch} from './state.mjs'\n\n/**\n * This class implements a pluggable data model, where you can\n * add effects that are run only when either an option for that\n * effect changes, or when an effect earlier in the chain of\n * effects changes.\n */\nclass SimplyFlowModel {\n\n\t/**\n\t * Creates a new datamodel, with a state property that contains\n\t * all the data passed to this constructor\n\t * @param state\tObject with all the data for this model\n\t */\n\tconstructor(state) {\n\t\tthis.state = signal(state)\n\t\tif (!this.state.options) {\n\t\t\tthis.state.options = {}\n\t\t}\n\t\tthis.effects = [{current:state.data}]\n\t\tthis.view = signal(state.data)\n\t}\n\n\t/**\n\t * Adds an effect to run whenever a signal it depends on\n\t * changes. this.state is the usual signal.\n\t * The `fn` function param is not itself an effect, but must return\n\t * and effect function. `fn` takes one param, which is the data signal.\n\t * This signal will always have at least a `current` property.\n\t * The result of the effect function is pushed on to the this.effects\n\t * list. And the last effect added is set as this.view\n\t */\n\taddEffect(fn) {\n\t\tconst dataSignal = this.effects[this.effects.length-1]\n\t\tthis.view = fn.call(this, dataSignal)\n\t\tthis.effects.push(this.view)\n\t}\n}\n\nexport function model(options) {\n\treturn new SimplyFlowModel(options)\n}\n\n/**\n * Returns a function for model.addEffect that sorts the input data\n * \n * Options:\n * - direction (string) default 'asc' - change to 'desc' to sort in descending order\n * - sortBy (string) (optional) - used by the default sorting function to select the property to sort on\n * - sortFn (function) (required - set by default) - the sort function to use\n */\nexport function sort(options={}) {\n\treturn function(data) {\n\t\t// initialize the sort options, only gets called once\n\t\tthis.state.options.sort = Object.assign({\n\t\t\tdirection: 'asc',\n\t\t\tsortBy: null,\n\t\t\tsortFn: ((a,b) => {\n\t\t\t\tconst sort = this.state.options.sort\n\t\t\t\tconst sortBy = sort.sortBy\n\t\t\t\tif (!sort.sortBy) {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t\tconst larger = sort.direction == 'asc' ? 1 : -1\n\t\t\t\tconst smaller = sort.direction == 'asc' ? -1 : 1\n\t\t\t\tif (typeof a?.[sortBy] === 'undefined') {\n\t\t\t\t\tif (typeof b?.[sortBy] === 'undefined') {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\treturn larger\n\t\t\t\t}\n\t\t\t\tif (typeof b?.[sortBy] === 'undefined') {\n\t\t\t\t\treturn smaller\n\t\t\t\t}\n\t\t\t\tif (a[sortBy]<b[sortBy]) {\n\t\t\t\t\treturn smaller\n\t\t\t\t} else if (a[sortBy]>b[sortBy]) {\n\t\t\t\t\treturn larger\n\t\t\t\t} else {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t})\n\t\t}, options);\n\t\t// then return the effect, which is called when\n\t\t// either the data or the sort options change\n\t\treturn throttledEffect(() => {\n\t\t\tconst sort = this.state.options.sort\n\t\t\tif (sort?.sortBy && sort?.direction) {\n\t\t\t\treturn data.current.toSorted(sort?.sortFn)\n\t\t\t}\n\t\t\treturn data.current\n\t\t}, 50)\n\t}\n}\n\n/**\n * Returns a function for model.addEffect that implements paging\n * for the input data. It will return a slice of the data matching\n * the page and pageSize options.\n * \n * Options:\n * - page (int) default 1 - which page to show, starts at 1\n * - pageSize (int) default 20 - how many items in a single page\n * - max (int) (calculated) - how many pages in total\n */\nexport function paging(options={}) {\n\treturn function(data) {\n\t\t// initialize the paging options\n\t\tthis.state.options.paging = Object.assign({\n\t\t\tpage: 1,\n\t\t\tpageSize: 20,\n\t\t\tmax: 1\n\t\t}, options)\n\t\treturn throttledEffect(() => {\n\t\t\treturn batch(() => {\n\t\t\t\tconst paging = this.state.options.paging\n\t\t\t\tif (!paging.pageSize) {\n\t\t\t\t\tpaging.pageSize = 20\n\t\t\t\t}\n\t\t\t\tpaging.max = Math.ceil(this.state.data.length / paging.pageSize)\n\t\t\t\tpaging.page = Math.max(1, Math.min(paging.max, paging.page))\n\n\t\t\t\tconst start = (paging.page-1) * paging.pageSize\n\t\t\t\tconst end = start + paging.pageSize\n\t\t\t\treturn data.current.slice(start, end)\n\t\t\t})\n\t\t}, 50)\n\t}\n}\n\n/**\n * Returns a function for model.addEffect that filters rows from the data,\n * using a custom filter function `options.matches`\n * \n * Options:\n * - name (string) (required) - the name of this filter, must be unique\n * - matches (function) (required) - the filter function to apply to the data\n */\nexport function filter(options) {\n\tif (!options?.name || typeof options.name!=='string') {\n\t\tthrow new Error('filter requires options.name to be a string')\n\t}\n\tif (!options.matches || typeof options.matches!=='function') {\n\t\tthrow new Error('filter requires options.matches to be a function')\n\t}\n\treturn function(data) {\n\t\tif (this.state.options[options.name]) {\n\t\t\tthrow new Error('a filter with this name already exists on this model')\n\t\t}\n\t\tthis.state.options[options.name] = options\n\t\treturn throttledEffect(() => {\n\t\t\tif (this.state.options[options.name].enabled) {\n\t\t\t\treturn data.current.filter(this.state.options[options.name].matches.bind(this))\n\t\t\t}\n\t\t\treturn data.current\n\t\t}, 50)\n\t}\n}\n\n/**\n * Returns a function for model.addEffect that filters the data to only contain\n * columns (properties) that aren't hidden. Automatically runs again if any columns\n * hidden property changes.\n * \n * Options:\n * - columns (object) (required) - an object with properties describing each column. Each \n * property must be an object with an optional `hidden` property. If set to a truthy value,\n * and property in the dataset with the same name, will be filtered out.\n */\nexport function columns(options={}) {\n\tif (!options\n\t\t|| typeof options!=='object'\n\t\t|| Object.keys(options).length===0) {\n\t\tthrow new Error('columns requires options to be an object with at least one property')\n\t}\n\treturn function(data) {\n\t\tthis.state.options.columns = options\n\t\treturn throttledEffect(() => {\n\t\t\treturn data.current.map(input => {\n\t\t\t\tlet result = {}\n\t\t\t\tfor (let key of Object.keys(this.state.options.columns)) {\n\t\t\t\t\tif (!this.state.options.columns[key]?.hidden) {\n\t\t\t\t\t\tresult[key] = input[key]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t})\n\t\t}, 50)\n\t}\n}\n\n/**\n * Returns a function for use with model.addEffect, with the given options set\n * as model.options.scroll. The effect will return a slice of the input data, which\n * makes it easy to render just a part (slice) of the whole data.\n * \n * Options are:\n * - offset (int) default 0 (optional) - the offset in the data to start the slice\n * - rowCount (int) default 20 (optional / calculated) - the number of rows in the slice\n * - rowHeight (int) default 26 (optional) - the height of a single row in pixels\n * - itemsPerRow (int) default 1 (optional) - the number of items on a single row\n * - size (int) default data.current.length (calculated) - how many rows inside data.current before slicing\n * - scrollbar (HTMLElement) defualt null (optional) - if set, an effect is added to update this elements \n * \t height if data.current.length changes\n * - container (HTMLElement) default null (optional) - if set, a scroll listener is added to this element, \n *   which will update the options.offset signal and trigger the slice effect. It will also set the rowCount.\n */\nexport function scroll(options) {\n\n\treturn function(data) {\n\t\tthis.state.options.scroll = Object.assign({\n\t\t\toffset: 0,\n\t\t\trowHeight: 26,\n\t\t\trowCount: 20,\n\t\t\titemsPerRow: 1,\n\t\t\tsize: data.current.length\n\t\t}, options)\n\t\tconst scrollOptions = this.state.options.scroll\n\n\t\tconst scrollbar = scrollOptions.scrollbar \n\t\t\t|| scrollOptions.container?.querySelector('[data-flow-scrollbar]')\n\t\tif (scrollbar) {\n\t\t\tif (scrollOptions.container) {\n\t\t\t\tscrollOptions.container.addEventListener('scroll', (evt) => {\n\t\t\t\t\tscrollOptions.offset = Math.floor(scrollOptions.container.scrollTop\n\t\t\t\t\t\t/ (scrollOptions.rowHeight*scrollOptions.itemsPerRow)\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthrottledEffect(() => {\n\t\t\t\tscrollOptions.size = data.current.length * scrollOptions.rowHeight\n\t\t\t\tscrollbar.style.height = scrollOptions.size + 'px'\n\t\t\t}, 50)\n\t\t}\n\n\t\treturn throttledEffect(() => {\n\t\t\tif (scrollOptions.container) {\n\t\t\t\t//TODO: add a resize listener so that if the size of the container\n\t\t\t\t// changes, the rowCount is calculated again\n\t\t\t\tscrollOptions.rowCount = Math.ceil(\n\t\t\t\t\tscrollOptions.container.getBoundingClientRect().height \n\t\t\t\t\t/ scrollOptions.rowHeight\n\t\t\t\t)\n\t\t\t}\n\t\t\tscrollOptions.data = data.current\n\t\t\tlet start = Math.min(scrollOptions.offset, data.current.length-1)\n\t\t\tlet end   = start + scrollOptions.rowCount\n\t\t\tif (end > data.current.length) {\n\t\t\t\tend   = data.current.length\n\t\t\t\tstart = end - scrollOptions.rowCount\n\t\t\t}\n\t\t\treturn data.current.slice(start, end)\n\t\t}, 50)\n\t}\n}", "import { bind } from './bind.mjs'\nimport * as model from './model.mjs'\nimport * as state from './state.mjs'\n\nif (!window.simply) {\n\twindow.simply = {}\n}\nObject.assign(window.simply, {\n\tbind,\n\tflow: model,\n\tstate\n})\n\nexport default window.simply"],
  "mappings": "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",
  "names": ["state_exports", "__export", "batch", "clockEffect", "destroy", "effect", "signal", "throttledEffect", "trace", "untracked", "iterate", "signalHandler", "target", "property", "receiver", "value", "notifyGet", "args", "l", "result", "notifySet", "makeContext", "current", "signals", "descriptor", "v", "prop", "getListeners", "listener", "batchedListeners", "batchMode", "self", "context", "listeners", "change", "propListeners", "addContext", "currentEffect", "computeStack", "clearContext", "currentCompute", "setListeners", "listenersMap", "computeMap", "compute", "connectedSignals", "clearListeners", "s", "effectStack", "effectMap", "signalStack", "fn", "f", "connectedSignal", "computeEffect", "runBatchedListeners", "copyBatchedListeners", "throttleTime", "throttled", "hasChange", "clock", "lastTick", "hasChanged", "remember", "SimplyBind", "options", "defaultOptions", "defaultFieldTransformer", "defaultListTransformer", "defaultMapTransformer", "attribute", "bindAttributes", "bindSelector", "transformAttribute", "getBindingAttribute", "el", "foundAttribute", "attr", "render", "throttledEffect", "untrack", "destroy", "context", "getValueByPath", "track", "runTransformers", "transformers", "t", "next", "transformer", "applyBindings", "bindings", "bindingEl", "updateBindings", "changes", "selector", "change", "node", "path", "templates", "list", "index", "parent", "value", "template", "result", "clone", "attributes", "binding", "bind", "templateMatches", "currentItem", "strItem", "matches", "rel", "replacement", "tracking", "track", "el", "context", "tracking", "untrack", "path", "list", "matchValue", "a", "b", "getValueByPath", "root", "parts", "curr", "part", "prevPart", "defaultFieldTransformer", "templates", "templatesCount", "value", "attribute", "transformLiteralByTemplates", "transformInput", "transformButton", "transformSelect", "transformAnchor", "transformImage", "transformIframe", "transformMeta", "transformElement", "defaultListTransformer", "transformArrayByTemplates", "defaultMapTransformer", "transformObjectByTemplates", "items", "lastKey", "skipped", "item", "currentKey", "bindings", "needsReplacement", "databind", "newTemplate", "length", "key", "clone", "outOfOrderItem", "i", "getParentPath", "parentEl", "rendered", "template", "setProperties", "option", "o", "setSelectOptions", "addOption", "select", "options", "strValue", "data", "properties", "property", "model_exports", "__export", "columns", "filter", "model", "paging", "scroll", "sort", "SimplyFlowModel", "state", "signal", "fn", "dataSignal", "model", "options", "sort", "data", "a", "b", "sortBy", "larger", "smaller", "throttledEffect", "paging", "batch", "start", "end", "filter", "columns", "input", "result", "key", "scroll", "scrollOptions", "scrollbar", "evt", "bind", "model_exports", "state_exports", "flow_default"]
}
