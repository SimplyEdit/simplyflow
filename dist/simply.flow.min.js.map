{
  "version": 3,
  "sources": ["../src/state.mjs", "../src/bind.mjs", "../src/model.mjs", "../src/flow.mjs"],
  "sourcesContent": ["const iterate = Symbol('iterate')\nif (!Symbol.xRay) {\n    Symbol.xRay = Symbol('xRay')\n}\n\nconst signalHandler = {\n    get: (target, property, receiver) => {\n        if (property===Symbol.xRay) {\n            return target // don't notifyGet here, this is only called by set\n        }\n        const value = target?.[property] // Reflect.get fails on a Set.\n        notifyGet(receiver, property)\n        if (typeof value === 'function') {\n            if (Array.isArray(target)) {\n                return (...args) => {\n                    let l = target.length\n                    // by binding the function to the receiver\n                    // all accesses in the function will be trapped\n                    // by the Proxy, so get/set/delete is all handled\n                    let result = value.apply(receiver, args)\n                    if (l != target.length) {\n                        notifySet(receiver,  makeContext('length', { was: l, now: target.length }) )\n                    }\n                    return result\n                }\n            } else if (target instanceof Set || target instanceof Map) {\n                return (...args) => {\n                    // node doesn't allow you to call set/map functions\n                    // bound to the receiver.. so using target instead\n                    // there are no properties to update anyway, except for size\n                    let s = target.size\n                    let result = value.apply(target, args)\n                    if (s != target.size) {\n                        notifySet(receiver, makeContext( 'size', { was: s, now: target.size }) )\n                    }\n                    // there is no efficient way to see if the function called\n                    // has actually changed the Set/Map, but by assuming the\n                    // 'setter' functions will change the results of the\n                    // 'getter' functions, effects should update correctly\n                    if (['set','add','clear','delete'].includes(property)) {\n                        notifySet(receiver, makeContext( { entries: {}, forEach: {}, has: {}, keys: {}, values: {}, [Symbol.iterator]: {} } ) )\n                    }\n                    return result\n                }\n            } else if (\n                target instanceof HTMLElement\n                || target instanceof Number\n                || target instanceof String\n                || target instanceof Boolean\n            ) {\n                return value.bind(target)\n            } else {\n                // support custom classes, hopefully\n                return value.bind(receiver)\n            }\n        }\n        if (value && typeof value == 'object') {\n            //NOTE: get now returns a signal, set doesn't 'unsignal' the value set\n            return signal(value)\n        }\n        return value\n    },\n    set: (target, property, value, receiver) => {\n        value = value?.[Symbol.xRay] || value // unwraps signal\n        let current = target[property]\n        if (current!==value) {\n            target[property] = value\n            notifySet(receiver, makeContext(property, { was: current, now: value } ) )\n        }\n        if (typeof current === 'undefined') {\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return true\n    },\n    has: (target, property) => { // receiver is not part of the has() call\n        let receiver = signals.get(target) // so retrieve it here\n        if (receiver) {\n            notifyGet(receiver, property)\n        }\n        return Object.hasOwn(target, property)\n    },\n    deleteProperty: (target, property) => {\n        if (typeof target[property] !== 'undefined') {\n            let current = target[property]\n            delete target[property]\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(property,{ delete: true, was: current }))\n        }\n        return true\n    },\n    defineProperty: (target, property, descriptor) => {\n        if (typeof target[property] === 'undefined') {\n            let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n            notifySet(receiver, makeContext(iterate, {}))\n        }\n        return Object.defineProperty(target, property, descriptor)\n    },\n    ownKeys: (target) => {\n        let receiver = signals.get(target) // receiver is not part of the trap arguments, so retrieve it here\n        notifyGet(receiver, iterate)\n        return Reflect.ownKeys(target)\n    }\n\n}\n\n/**\n * Keeps track of the return signal for an update function, as well\n * as signals connected to other objects. \n * Makes sure that a given object or function always uses the same\n * signal\n */\nconst signals = new WeakMap()\n\n/**\n * Creates a new signal proxy of the given object, that intercepts get/has and set/delete\n * to allow reactive functions to be triggered when signal values change.\n */\nexport function signal(v) {\n    if (!signals.has(v)) {\n        signals.set(v, new Proxy(v, signalHandler))\n    }\n    return signals.get(v)\n}\n\nlet batchedListeners = new Set()\nlet batchMode = 0\n/**\n * Called when a signal changes a property (set/delete)\n * Triggers any reactor function that depends on this signal\n * to re-compute its values\n */\nfunction notifySet(self, context={}) {\n    let listeners = []\n    context.forEach((change, property) => {\n        let propListeners = getListeners(self, property)\n        if (propListeners?.length) {\n            for (let listener of propListeners) {\n                addContext(listener, makeContext(property,change))\n            }\n            listeners = listeners.concat(propListeners)\n        }\n    })\n    listeners = new Set(listeners.filter(Boolean))\n    if (listeners) {\n        if (batchMode) {\n            batchedListeners = batchedListeners.union(listeners)\n        } else {\n            const currentEffect = computeStack[computeStack.length-1]\n            for (let listener of Array.from(listeners)) {\n                if (listener!=currentEffect && listener?.needsUpdate) {\n                    listener()\n                }\n                clearContext(listener)\n            }\n        }\n    }\n}\n\nfunction makeContext(property, change) {\n    let context = new Map()\n    if (typeof property === 'object') {\n        for (let prop in property) {\n            context.set(prop, property[prop])\n        }\n    } else {\n        context.set(property, change)\n    }\n    return context\n}\n\nfunction addContext(listener, context) {\n    if (!listener.context) {\n        listener.context = context\n    } else {\n        context.forEach((change,property)=> {\n            listener.context.set(property, change) // TODO: merge change if needed\n        })\n    }\n    listener.needsUpdate = true\n}\n\nfunction clearContext(listener) {\n    delete listener.context\n    delete listener.needsUpdate\n}\n\n/**\n * Called when a signal property is accessed. If this happens\n * inside a reactor function--computeStack is not empty--\n * then it adds the current reactor (top of this stack) to its\n * listeners. These are later called if this property changes\n */\nfunction notifyGet(self, property) {\n    let currentCompute = computeStack[computeStack.length-1]\n    if (currentCompute) {\n        // get was part of a react() function, so add it\n        setListeners(self, property, currentCompute)\n    }\n}\n\n/**\n * Keeps track of which update() functions are dependent on which\n * signal objects and which properties. Maps signals to update fns\n */\nconst listenersMap = new WeakMap()\n\n/**\n * Keeps track of which signals and properties are linked to which\n * update functions. Maps update functions and properties to signals\n */\nconst computeMap = new WeakMap()\n\n/**\n * Returns the update functions for a given signal and property\n */\nfunction getListeners(self, property) {\n    let listeners = listenersMap.get(self)\n    return listeners ? Array.from(listeners.get(property) || []) : []\n}\n\n/**\n * Adds an update function (compute) to the list of listeners on\n * the given signal (self) and property\n */\nfunction setListeners(self, property, compute) {\n    if (!listenersMap.has(self)) {\n        listenersMap.set(self, new Map())\n    }\n    let listeners = listenersMap.get(self)\n    if (!listeners.has(property)) {\n        listeners.set(property, new Set())\n    }\n    listeners.get(property).add(compute)\n\n    if (!computeMap.has(compute)) {\n        computeMap.set(compute, new Map())\n    }\n    let connectedSignals = computeMap.get(compute)\n    if (!connectedSignals.has(property)) {\n        connectedSignals.set(property, new Set)\n    }\n    connectedSignals.get(property).add(self)\n}\n\n/**\n * Removes alle listeners that trigger the given reactor function (compute)\n * This happens when a reactor is called, so that it can set new listeners\n * based on the current call (code path)\n */\nfunction clearListeners(compute) {\n    let connectedSignals = computeMap.get(compute)\n    if (connectedSignals) {\n        connectedSignals.forEach(property => {\n            property.forEach(s => {\n                let listeners = listenersMap.get(s)\n                if (listeners.has(property)) {\n                    listeners.get(property).delete(compute)\n                }\n            })\n        })\n    }\n}\n\n/**\n * The top most entry is the currently running update function, used\n * to automatically record signals used in an update function.\n */\nlet computeStack = []\n\n/**\n * Used for cycle detection: effectStack contains all running effect\n * functions. If the same function appears twice in this stack, there\n * is a recursive update call, which would cause an infinite loop.\n */\nconst effectStack = []\n\nconst effectMap = new WeakMap()\n/**\n * Used for cycle detection: signalStack contains all used signals. \n * If the same signal appears more than once, there is a cyclical \n * dependency between signals, which would cause an infinite loop.\n */\nconst signalStack = []\n\n/**\n * Runs the given function at once, and then whenever a signal changes that\n * is used by the given function (or at least signals used in the previous run).\n */\nexport function effect(fn) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n    }\n    computeEffect.fn = fn\n    effectMap.set(connectedSignal, computeEffect)\n\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n\nexport function destroy(connectedSignal) {\n    // find the computeEffect associated with this signal\n    const computeEffect = effectMap.get(connectedSignal)?.deref()\n    if (!computeEffect) {\n        return\n    }\n\n    // remove all listeners for this effect\n    clearListeners(computeEffect)\n\n    // remove all references to connectedSignal\n    let fn = computeEffect.fn\n    signals.remove(fn)\n\n    effectMap.delete(connectedSignal)\n\n    // if no other references to connectedSignal exist, it will be garbage collected\n}\n\n/**\n * Inside a batch() call, any changes to signals do not trigger effects\n * immediately. Instead, immediately after finishing the batch() call,\n * these effects will be called. Effects that are triggered by multiple\n * signals are called only once.\n * @param Function fn batch() calls this function immediately\n * @result mixed the result of the fn() function call\n */\nexport function batch(fn) {\n    batchMode++\n    let result\n    try {\n        result = fn()\n    } finally {\n        if (result instanceof Promise) {\n            result.then(() => {\n                batchMode--\n                if (!batchMode) {\n                    runBatchedListeners()\n                }\n            })\n        } else {\n            batchMode--\n            if (!batchMode) {\n                runBatchedListeners()\n            }\n        }\n    }\n    return result\n}\n\nfunction runBatchedListeners() {\n    let copyBatchedListeners = Array.from(batchedListeners)\n    batchedListeners = new Set()\n    const currentEffect = computeStack[computeStack.length-1]\n    for (let listener of copyBatchedListeners) {\n        if (listener!=currentEffect && listener?.needsUpdate) {\n            listener()\n        }\n        clearContext(listener)\n    }\n}\n\n/**\n * A throttledEffect is run immediately once. And then only once\n * per throttleTime (in ms).\n * @param Function fn the effect function to run whenever a signal changes\n * @param int throttleTime in ms\n * @returns signal with the result of the effect function fn\n */\nexport function throttledEffect(fn, throttleTime) {\n    if (effectStack.findIndex(f => fn==f)!==-1) {\n        throw new Error('Recursive update() call', {cause:fn})\n    }\n    effectStack.push(fn)\n\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let throttled = false\n    let hasChange = true\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (signalStack.findIndex(s => s==connectedSignal)!==-1) {\n            throw new Error('Cyclical dependency in update() call', { cause: fn})\n        }\n        if (throttled && throttled>Date.now()) {\n            hasChange = true\n            return\n        }\n        // remove all dependencies (signals) from previous runs \n        clearListeners(computeEffect)\n        // record new dependencies on this run\n        computeStack.push(computeEffect)\n        // prevent recursion\n        signalStack.push(connectedSignal)\n        // call the actual update function\n        let result\n        try {\n            result = fn(computeEffect, computeStack, signalStack)\n        } finally {\n            hasChange = false\n            // stop recording dependencies\n            computeStack.pop()\n            // stop the recursion prevention\n            signalStack.pop()\n            if (result instanceof Promise) {\n                result.then((result) => {\n                    connectedSignal.current = result\n                })\n            } else {\n                connectedSignal.current = result\n            }\n        }\n        throttled = Date.now()+throttleTime\n        globalThis.setTimeout(() => {\n            if (hasChange) {\n                computeEffect()\n            }\n        }, throttleTime)\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\n// refactor: Class clock() with an effect() method\n// keep track of effects per clock, and add clock property to the effect function\n// on notifySet add clock.effects to clock.needsUpdate list\n// on clock.tick() (or clock.time++) run only the clock.needsUpdate effects \n// (first create a copy and reset clock.needsUpdate, then run effects)\nexport function clockEffect(fn, clock) {\n    let connectedSignal = signals.get(fn)\n    if (!connectedSignal) {\n        connectedSignal = signal({\n            current: null\n        })\n        signals.set(fn, connectedSignal)\n    }\n\n    let lastTick = -1 // clock.time should start at 0 or larger\n    let hasChanged = true // make sure the first run goes through\n    // this is the function that is called automatically\n    // whenever a signal dependency changes\n    const computeEffect = function computeEffect() {\n        if (lastTick < clock.time) {\n            if (hasChanged) {\n                // remove all dependencies (signals) from previous runs \n                clearListeners(computeEffect)\n                // record new dependencies on this run\n                computeStack.push(computeEffect)\n                // make sure the clock.time signal is a dependency\n                lastTick = clock.time\n                // call the actual update function\n                let result \n                try {\n                    result = fn(computeEffect, computeStack)\n                } finally {\n                    // stop recording dependencies\n                    computeStack.pop()\n                    if (result instanceof Promise) {\n                        result.then((result) => {\n                            connectedSignal.current = result\n                        })\n                    } else {\n                        connectedSignal.current = result\n                    }\n                    hasChanged = false\n                }\n            } else {\n                lastTick = clock.time\n            }\n        } else {\n            hasChanged = true\n        }\n    }\n    // run the computEffect immediately upon creation\n    computeEffect()\n    return connectedSignal\n}\n\nexport function untracked(fn) {\n    const remember = computeStack.slice()\n    computeStack = []\n    try {\n        return fn()\n    } finally {\n        computeStack = remember\n    }\n}", "import { throttledEffect, destroy } from './state.mjs'\n\nclass SimplyBind {\n    constructor(options) {\n        this.bindings = new Map()\n        const defaultOptions = {\n            container: document.body,\n            attribute: 'data-bind',\n            transformers: [],\n            defaultTransformers: {\n                field: [defaultFieldTransformer],\n                list: [defaultListTransformer],\n                map: [defaultMapTransformer]\n            }\n        }\n        if (!options?.root) {\n            throw new Error('bind needs at least options.root set')\n        }\n        this.options = Object.assign({}, defaultOptions, options)\n\n        const attribute      = this.options.attribute\n        const bindAttributes = [attribute+'-field',attribute+'-list',attribute+'-map']\n        const bindSelector   = `[${attribute}-field],[${attribute}-list],[${attribute}-map]`\n\n        const getBindingAttribute = (el) => {\n            const foundAttribute = bindAttributes.find(attr => el.hasAttribute(attr))\n            if (!foundAttribute) {\n                console.error('No matching attribute found',el)\n            }\n            return foundAttribute\n        }\n\n        // sets up the effect that updates the element if its\n        // data binding value changes\n\n        const render = (el) => {\n            this.bindings.set(el, throttledEffect(() => {\n                const context = {\n                    templates: el.querySelectorAll(':scope > template'),\n                    attribute: getBindingAttribute(el)\n                }\n                context.path = this.getBindingPath(el)\n                context.value = getValueByPath(this.options.root, context.path)\n                context.element = el\n                runTransformers(context)\n            }, 100))\n        }\n\n        // finds and runs applicable transformers\n        // creates a stack of transformers, calls the topmost\n        // each transformer can opt to call the next or not\n        // transformers should return the context object (possibly altered)\n        const runTransformers = (context) => {\n            let transformers\n            switch(context.attribute) {\n                case this.options.attribute+'-field':\n                    transformers = this.options.defaultTransformers.field || []\n                    break\n                case this.options.attribute+'-list':\n                    transformers = this.options.defaultTransformers.list || []\n                    break\n                case this.options.attribute+'-map':\n                    transformers = this.options.defaultTransformers.map || []\n                    break\n            }\n            if (context.element.dataset.transform) {\n                context.element.dataset.transform.split(' ').filter(Boolean).forEach(t => {\n                    if (this.options.transformers[t]) {\n                        transformers.push(this.options.transformers[t])\n                    } else {\n                        console.warn('No transformer with name '+t+' configured', {cause:context.element})\n                    }\n                })\n            }\n            let next\n            for (let transformer of transformers) {\n                next = ((next, transformer) => {\n                    return (context) => {\n                        return transformer.call(this, context, next)\n                    }\n                })(next, transformer)\n            }\n            next(context)\n        }\n\n        // given a set of elements with data bind attribute\n        // this renders each of those elements\n        const applyBindings = (bindings) => {\n            for (let bindingEl of bindings) {\n                render(bindingEl)\n            }\n        }\n\n        // this handles the mutation observer changes\n        // if any element is added, and has a data bind attribute\n        // it applies that data binding\n        const updateBindings = (changes) => {\n            const selector = `[${attribute}-field],[${attribute}-list],[${attribute}-map]`\n            for (const change of changes) {\n                if (change.type==\"childList\" && change.addedNodes) {\n                    for (let node of change.addedNodes) {\n                        if (node instanceof HTMLElement) {\n                            let bindings = Array.from(node.querySelectorAll(selector))\n                            if (node.matches(selector)) {\n                                bindings.unshift(node)\n                            }\n                            if (bindings.length) {\n                                applyBindings(bindings)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // this responds to elements getting added to the dom\n        // and if any have data bind attributes, it applies those bindings\n        this.observer = new MutationObserver((changes) => {\n            updateBindings(changes)\n        })\n\n        this.observer.observe(options.container, {\n            subtree: true,\n            childList: true\n        })\n\n        // this finds elements with data binding attributes and applies those bindings\n        // must come after setting up the observer, or included templates\n        // won't trigger their own bindings\n        const bindings = this.options.container.querySelectorAll(\n            '['+this.options.attribute+'-field]'+\n            ',['+this.options.attribute+'-list]'+\n            ',['+this.options.attribute+'-map]'\n        )\n        if (bindings.length) {\n            applyBindings(bindings)\n        }\n\n    }\n\n    /**\n     * Finds the first matching template and creates a new DocumentFragment\n     * with the correct data bind attributes in it (prepends the current path)\n     */\n    applyTemplate(context) {\n        const path      = context.path\n        const templates = context.templates\n        const list      = context.list\n        const index     = context.index\n        const parent    = context.parent\n        const value     = list ? list[index] : context.value\n\n        let template = this.findTemplate(templates, value)\n        if (!template) {\n            let result = new DocumentFragment()\n            result.innerHTML = '<!-- no matching template -->'\n            return result\n        }\n        let clone = template.content.cloneNode(true)\n        if (!clone.children?.length) {\n            return clone\n        }\n        if (clone.children.length>1) {\n            throw new Error('template must contain a single root node', { cause: template })\n        }\n        const attribute = this.options.attribute\n        const attributes = [attribute+'-field',attribute+'-list',attribute+'-map']\n        const bindings = clone.querySelectorAll(`[${attribute}-field],[${attribute}-list],[${attribute}-map]`)\n        for (let binding of bindings) {\n            const attr = attributes.find(attr => binding.hasAttribute(attr))\n            const bind = binding.getAttribute(attr)\n            if (bind.substring(0, ':root.'.length)==':root.') {\n                binding.setAttribute(attr, bind.substring(':root.'.length))\n            } else if (bind==':value' && index!=null) {\n                binding.setAttribute(attr, path+'.'+index)\n            } else if (index!=null) {\n                binding.setAttribute(attr, path+'.'+index+'.'+bind)\n            } else {\n                binding.setAttribute(attr, parent+'.'+bind)\n            }\n        }\n        if (typeof index !== 'undefined') {\n            clone.children[0].setAttribute(attribute+'-key',index)\n        }\n        // keep track of the used template, so if that changes, the \n        // item can be updated\n        clone.children[0].$bindTemplate = template\n        return clone\n    }\n\n    getBindingPath(el) {\n        const attributes = [\n            this.options.attribute+'-field', \n            this.options.attribute+'-list',\n            this.options.attribute+'-map'\n        ]\n        for (let attr of attributes) {\n            if (el.hasAttribute(attr)) {\n                return el.getAttribute(attr)\n            }\n        }\n    }\n\n    /**\n     * Finds the first template from an array of templates that\n     * matches the given value. \n     */\n    findTemplate(templates, value) {\n        const templateMatches = t => {\n            // find the value to match against (e.g. data-bind=\"foo\")\n            let path = this.getBindingPath(t)\n            let currentItem\n            if (path) {\n                if (path.substr(0,6)==':root.') {\n                    currentItem = getValueByPath(this.options.root, path)\n                } else {\n                    currentItem = getValueByPath(value, path)\n                }\n            } else {\n                currentItem = value\n            }\n\n            // then check the value against pattern, if set (e.g. data-bind-match=\"bar\")\n            const strItem = ''+currentItem\n            let matches = t.getAttribute(this.options.attribute+'-match')\n            if (matches) {\n                if (matches===':empty' && !currentItem) {\n                    return t\n                } else if (matches===':notempty' && currentItem) {\n                    return t\n                }\n                if (strItem.match(matches)) {\n                    return t\n                }\n            }\n            if (!matches && currentItem!==null && currentItem!==undefined) {\n                //FIXME: this doesn't run templates in lists where list entry is null\n                //which messes up the count\n                //\n                // no data-bind-match is set, so return this template\n                return t\n            }\n        }\n        let template = Array.from(templates).find(templateMatches)\n        let rel = template?.getAttribute('rel')\n        if (rel) {\n            let replacement = document.querySelector('template#'+rel)\n            if (!replacement) {\n                throw new Error('Could not find template with id '+rel)\n            }\n            template = replacement\n        }\n        return template\n    }\n\n    destroy() {\n        this.bindings.forEach(binding => {\n            destroy(binding)\n        })\n        this.bindings = new Map()\n        this.observer.disconnect()\n    }\n\n}\n\n/**\n * Returns a new instance of SimplyBind. This is the normal start\n * of a data bind flow\n */\nexport function bind(options)\n{\n    return new SimplyBind(options)\n}\n\n/**\n * Returns true if a matches b, either by having the\n * same string value, or matching string :empty against a falsy value\n */\nexport function matchValue(a,b) {\n    if (a==':empty' && !b) {\n        return true\n    }\n    if (b==':empty' && !a) {\n        return true\n    }\n    if (''+a == ''+b) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns the value by walking the given path\n * as a json pointer, starting at root\n * if you have a property with a '.' in its name\n * urlencode the '.', e.g: %46\n */\nexport function getValueByPath(root, path)\n{\n    let parts = path.split('.');\n    let curr = root;\n    let part, prevPart;\n    while (parts.length && curr) {\n        part = parts.shift()\n        if (part==':key') {\n            return prevPart\n        } else if (part==':value') {\n            return curr\n        } else if (part==':root') {\n            curr = root\n        } else {\n            part = decodeURIComponent(part)\n            curr = curr[part];\n            prevPart = part\n        }\n    }\n    return curr\n}\n\n/**\n * Default transformer for data binding\n * Will be used unless overriden in the SimplyBind options parameter\n */\nexport function defaultFieldTransformer(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (templates?.length) {\n        transformLiteralByTemplates.call(this, context)\n    } else if (el.tagName=='INPUT') {\n        transformInput.call(this, context)\n    } else if (el.tagName=='BUTTON') {\n        transformButton.call(this, context)\n    } else if (el.tagName=='SELECT') {\n        transformSelect.call(this, context)\n    } else if (el.tagName=='A') {\n        transformAnchor.call(this, context)\n    } else {\n        transformElement.call(this, context)\n    }\n    return context\n}\n\nexport function defaultListTransformer(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (!Array.isArray(value)) {\n        console.error('Value is not an array.', el, value)\n    } else if (!templates?.length) {\n        console.error('No templates found in', el)\n    } else {\n        transformArrayByTemplates.call(this, context)\n    }\n    return context\n}\n\nexport function defaultMapTransformer(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    if (typeof value != 'object') {\n        console.error('Value is not an object.', el, value)\n    } else if (!templates?.length) {\n        console.error('No templates found in', el)\n    } else {\n        transformObjectByTemplates.call(this, context)\n    }\n    return context\n}\n\n\n/**\n * Renders an array value by applying templates for each entry\n * Replaces or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n * FIXME: this doesn't handle situations where there is no matching template\n * this messes up self healing. check transformObjectByTemplates for a better implementation\n */\nexport function transformArrayByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    let items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    // do single merge strategy for now, in future calculate optimal merge strategy from a number\n    // now just do a delete if a key <= last key, insert if a key >= last key\n    let lastKey = 0\n    let skipped = 0\n    context.list  = value\n    for (let item of items) {\n        let currentKey = parseInt(item.getAttribute(attribute+'-key'))\n        if (currentKey>lastKey) {\n            // insert before\n            context.index = lastKey\n            el.insertBefore(this.applyTemplate(context), item)\n        } else if (currentKey<lastKey) {\n            // remove this\n            item.remove()\n        } else {\n            // check that all data-bind params start with current json path or ':root', otherwise replaceChild\n            let bindings = Array.from(item.querySelectorAll(`[${attribute}]`))\n            if (item.matches(`[${attribute}]`)) {\n                bindings.unshift(item)\n            }\n            let needsReplacement = bindings.find(b => {\n                let databind = b.getAttribute(attribute)\n                return (databind.substr(0,5)!==':root' \n                    && databind.substr(0, path.length)!==path)\n            })\n            if (!needsReplacement) {\n                if (item.$bindTemplate) {\n                    let newTemplate = this.findTemplate(templates, value[lastKey])\n                    if (newTemplate != item.$bindTemplate){\n                        needsReplacement = true\n                        if (!newTemplate) {\n                            skipped++\n                        }\n                    }\n                }\n            }\n            if (needsReplacement) {\n                context.index = lastKey\n                el.replaceChild(this.applyTemplate(context), item)\n            }\n        }\n        lastKey++\n        if (lastKey>=value.length) {\n            break\n        }\n    }\n    items = el.querySelectorAll(':scope > ['+attribute+'-key]')\n    let length = items.length + skipped\n    if (length > value.length) {\n        while (length > value.length) {\n            let child = el.querySelectorAll(':scope > :not(template)')?.[length-1]\n            child?.remove()\n            length--\n        }\n    } else if (length < value.length ) {\n        while (length < value.length) {\n            context.index = length\n            el.appendChild(this.applyTemplate(context))\n            length++\n        }\n    }\n}\n\n/**\n * Renders an object value by applying templates for each entry (Object.entries)\n * Replaces,moves or removes existing DOM children if needed\n * Reuses (doesn't touch) DOM children if template doesn't change\n */\nexport function transformObjectByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const templatesCount = templates.length \n    const path           = context.path\n    const value          = context.value\n    const attribute      = this.options.attribute\n    context.list = value\n\n    let items = Array.from(el.querySelectorAll(':scope > ['+attribute+'-key]'))\n    for (let key in context.list) {\n        context.index = key\n        let item = items.shift()\n        if (!item) { // more properties than rendered items\n            let clone = this.applyTemplate(context)\n            if (clone.firstElementChild) {\n                el.appendChild(clone)\n            }\n            continue\n        }\n        if (item.getAttribute[attribute+'-key']!=key) { \n            // next item doesn't match key\n            items.unshift(item) // put item back for next cycle\n            let outOfOrderItem = el.querySelector(':scope > ['+attribute+'-key=\"'+key+'\"]') //FIXME: escape key\n            if (!outOfOrderItem) {\n                let clone = this.applyTemplate(context)\n                if (clone.firstElementChild) {\n                    el.insertBefore(clone, item)\n                }\n                continue // new template doesn't need replacement, so continue \n            } else {\n                el.insertBefore(outOfOrderItem, item)\n                item = outOfOrderItem // check needsreplacement next\n                items = items.filter(i => i!=outOfOrderItem)\n            }\n        }\n        let newTemplate = this.findTemplate(templates, value[key])\n        if (newTemplate != item.$bindTemplate){\n            let clone = this.applyTemplate(context)\n            el.replaceChild(clone, item)\n        }\n    }\n    // clean up remaining items\n    while (items.length) {\n        item = items.shift()\n        item.remove()\n    }\n}\n\nfunction getParentPath(el, attribute) {\n    const parentEl  = el.parentElement?.closest(`[${attribute}-list],[${attribute}-map]`)\n    if (!parentEl) {\n        return ':root'\n    }\n    if (parentEl.hasAttribute(`${attribute}-list`)) {\n        return parentEl.getAttribute(`${attribute}-list`)\n    }\n    return parentEl.getAttribute(`${attribute}-map`)\n}\n\n/**\n * transforms the contents of an html element by rendering\n * a matching template, once.\n * data-bind attributes inside the template use the same\n * parent path as this html element uses\n */\nexport function transformLiteralByTemplates(context) {\n    const el             = context.element\n    const templates      = context.templates\n    const value          = context.value\n    const attribute      = this.options.attribute\n\n    const rendered = el.querySelector(':scope > :not(template)')\n    const template = this.findTemplate(templates, value)\n\n    context.parent = getParentPath(el, attribute)\n    if (rendered) {\n        if (template) {\n            if (rendered?.$bindTemplate != template) {\n                const clone = this.applyTemplate(context)\n                el.replaceChild(clone, rendered)\n            }\n        } else {\n            el.removeChild(rendered)\n        }\n    } else if (template) {\n        const clone = this.applyTemplate(context)\n        el.appendChild(clone)\n    }\n}\n\n/**\n * transforms a single input type\n * for radio/checkbox inputs it only sets the checked attribute to true/false\n * if the value attribute matches the current value\n * for other inputs the value attribute is updated\n * FIXME: handle radio/checkboxes in separate transformer\n */\nexport function transformInput(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.type=='checkbox' || el.type=='radio') {\n        if (matchValue(el.value, value)) {\n            el.checked = true\n        } else {\n            el.checked = false\n        }\n    } else if (!matchValue(el.value, value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the value of the button, doesn't touch the innerHTML\n */\nexport function transformButton(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.value,value)) {\n        el.value = ''+value\n    }\n}\n\n/**\n * Sets the selected attribute of select options\n */\nexport function transformSelect(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (el.multiple) {\n        if (Array.isArray(value)) {\n            for (let option of el.options) {\n                if (value.indexOf(option.value)===false) {\n                    option.selected = false\n                } else {\n                    option.selected = true\n                }\n            }\n        }\n    } else {\n        let option = el.options.find(o => matchValue(o.value,value))\n        if (option) {\n            option.selected = true\n        }\n    }\n}\n\n/**\n * Sets the innerHTML and href attribute of an anchor\n * TODO: support target, title, etc. attributes\n */\nexport function transformAnchor(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (value?.innerHTML && !matchValue(el.innerHTML, value.innerHTML)) {\n        el.innerHTML = ''+value.innerHTML\n    }\n    if (value?.href && !matchValue(el.href,value.href)) {\n        el.href = ''+value.href\n    }    \n}\n\n/**\n * sets the innerHTML of any HTML element\n */\nexport function transformElement(context) {\n    const el    = context.element\n    const value = context.value\n\n    if (!matchValue(el.innerHTML, value)) {\n        if (typeof value=='undefined' || value==null) {\n            el.innerHTML = ''\n        } else {\n            el.innerHTML = ''+value\n        }\n    }\n}", "import {signal, effect, batch} from './state.mjs'\n\n/**\n * This class implements a pluggable data model, where you can\n * add effects that are run only when either an option for that\n * effect changes, or when an effect earlier in the chain of\n * effects changes.\n */\nclass SimplyModel {\n\n\t/**\n\t * Creates a new datamodel, with a state property that contains\n\t * all the data passed to this constructor\n\t * @param state\tObject with all the data for this model\n\t */\n\tconstructor(state) {\n\t\tthis.state = signal(state)\n\t\tif (!this.state.options) {\n\t\t\tthis.state.options = {}\n\t\t}\n\t\tthis.effects = [{current:state.data}]\n\t\tthis.view = signal(state.data)\n\t}\n\n\t/**\n\t * Adds an effect to run whenever a signal it depends on\n\t * changes. this.state is the usual signal.\n\t * The `fn` function param is not itself an effect, but must return\n\t * and effect function. `fn` takes one param, which is the data signal.\n\t * This signal will always have at least a `current` property.\n\t * The result of the effect function is pushed on to the this.effects\n\t * list. And the last effect added is set as this.view\n\t */\n\taddEffect(fn) {\n\t\tconst dataSignal = this.effects[this.effects.length-1]\n\t\tthis.view = fn.call(this, dataSignal)\n\t\tthis.effects.push(this.view)\n\t}\n}\n\nexport function model(options) {\n\treturn new SimplyModel(options)\n}\n\nexport function sort(options={}) {\n\treturn function(data) {\n\t\t// initialize the sort options, only gets called once\n\t\tthis.state.options.sort = Object.assign({\n\t\t\tdirection: 'asc',\n\t\t\tsortBy: null,\n\t\t\tsortFn: ((a,b) => {\n\t\t\t\tconst sort = this.state.options.sort\n\t\t\t\tconst sortBy = sort.sortBy\n\t\t\t\tif (!sort.sortBy) {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t\tconst larger = sort.direction == 'asc' ? 1 : -1\n\t\t\t\tconst smaller = sort.direction == 'asc' ? -1 : 1\n\t\t\t\tif (typeof a?.[sortBy] === 'undefined') {\n\t\t\t\t\tif (typeof b?.[sortBy] === 'undefined') {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\treturn larger\n\t\t\t\t}\n\t\t\t\tif (typeof b?.[sortBy] === 'undefined') {\n\t\t\t\t\treturn smaller\n\t\t\t\t}\n\t\t\t\tif (a[sortBy]<b[sortBy]) {\n\t\t\t\t\treturn smaller\n\t\t\t\t} else if (a[sortBy]>b[sortBy]) {\n\t\t\t\t\treturn larger\n\t\t\t\t} else {\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t})\n\t\t}, options);\n\t\t// then return the effect, which is called when\n\t\t// either the data or the sort options change\n\t\treturn effect(() => {\n\t\t\tconst sort = this.state.options.sort\n\t\t\tif (sort?.sortBy && sort?.direction) {\n\t\t\t\treturn data.current.toSorted(sort?.sortFn)\n\t\t\t}\n\t\t\treturn data.current\n\t\t})\n\t}\n}\n\nexport function paging(options={}) {\n\treturn function(data) {\n\t\t// initialize the paging options\n\t\tthis.state.options.paging = Object.assign({\n\t\t\tpage: 1,\n\t\t\tpageSize: 20,\n\t\t\tmax: 1\n\t\t}, options)\n\t\treturn effect(() => {\n\t\t\treturn batch(() => {\n\t\t\t\tconst paging = this.state.options.paging\n\t\t\t\tif (!paging.pageSize) {\n\t\t\t\t\tpaging.pageSize = 20\n\t\t\t\t}\n\t\t\t\tpaging.max = Math.ceil(this.state.data.length / paging.pageSize)\n\t\t\t\tpaging.page = Math.max(1, Math.min(paging.max, paging.page))\n\n\t\t\t\tconst start = (paging.page-1) * paging.pageSize\n\t\t\t\tconst end = start + paging.pageSize\n\t\t\t\treturn data.current.slice(start, end)\n\t\t\t})\n\t\t})\n\t}\n}\n\nexport function filter(options) {\n\tif (!options?.name || typeof options.name!=='string') {\n\t\tthrow new Error('filter requires options.name to be a string')\n\t}\n\tif (!options.matches || typeof options.matches!=='function') {\n\t\tthrow new Error('filter requires options.matches to be a function')\n\t}\n\treturn function(data) {\n\t\tthis.state.options[options.name] = options\n\t\treturn effect(() => {\n\t\t\tif (this.state.options[options.name].enabled) {\n\t\t\t\treturn data.filter(this.state.options.matches)\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function columns(options={}) {\n\tif (!options\n\t\t|| typeof options!=='object'\n\t\t|| Object.keys(options).length===0) {\n\t\tthrow new Error('columns requires options to be an object with at least one property')\n\t}\n\treturn function(data) {\n\t\tthis.state.options.columns = options\n\t\treturn effect(() => {\n\t\t\treturn data.current.map(input => {\n\t\t\t\tlet result = {}\n\t\t\t\tfor (let key of Object.keys(this.state.options.columns)) {\n\t\t\t\t\tif (!this.state.options.columns[key].hidden) {\n\t\t\t\t\t\tresult[key] = input[key]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t})\n\t\t})\n\t}\n}", "import { bind } from './bind.mjs'\nimport * as model from './model.mjs'\nimport * as state from './state.mjs'\n\nif (!window.simply) {\n\twindow.simply = {}\n}\nObject.assign(window.simply, {\n\tbind,\n\tmodel,\n\tstate\n})\n\nexport default window.simply"],
  "mappings": "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",
  "names": ["state_exports", "__export", "batch", "clockEffect", "destroy", "effect", "signal", "throttledEffect", "untracked", "iterate", "signalHandler", "target", "property", "receiver", "value", "notifyGet", "args", "l", "result", "notifySet", "makeContext", "s", "current", "signals", "descriptor", "v", "batchedListeners", "batchMode", "self", "context", "listeners", "change", "propListeners", "getListeners", "listener", "addContext", "currentEffect", "computeStack", "clearContext", "prop", "currentCompute", "setListeners", "listenersMap", "computeMap", "compute", "connectedSignals", "clearListeners", "effectStack", "effectMap", "signalStack", "fn", "f", "connectedSignal", "computeEffect", "runBatchedListeners", "copyBatchedListeners", "throttleTime", "throttled", "hasChange", "clock", "lastTick", "hasChanged", "remember", "SimplyBind", "options", "defaultOptions", "defaultFieldTransformer", "defaultListTransformer", "defaultMapTransformer", "attribute", "bindAttributes", "bindSelector", "getBindingAttribute", "el", "foundAttribute", "attr", "render", "throttledEffect", "context", "getValueByPath", "runTransformers", "transformers", "t", "next", "transformer", "applyBindings", "bindings", "bindingEl", "updateBindings", "changes", "selector", "change", "node", "path", "templates", "list", "index", "parent", "value", "template", "result", "clone", "attributes", "binding", "bind", "templateMatches", "currentItem", "strItem", "matches", "rel", "replacement", "destroy", "matchValue", "a", "b", "root", "parts", "curr", "part", "prevPart", "templatesCount", "transformLiteralByTemplates", "transformInput", "transformButton", "transformSelect", "transformAnchor", "transformElement", "transformArrayByTemplates", "transformObjectByTemplates", "items", "lastKey", "skipped", "item", "currentKey", "needsReplacement", "databind", "newTemplate", "length", "key", "outOfOrderItem", "i", "getParentPath", "parentEl", "rendered", "option", "o", "model_exports", "__export", "columns", "filter", "model", "paging", "sort", "SimplyModel", "state", "signal", "fn", "dataSignal", "model", "options", "sort", "data", "a", "b", "sortBy", "larger", "smaller", "effect", "paging", "batch", "start", "end", "filter", "columns", "input", "result", "key", "bind", "model_exports", "state_exports", "flow_default"]
}
